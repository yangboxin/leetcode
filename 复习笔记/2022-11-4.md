### lc-754

在一根无限长的数轴上，你站在`0`的位置。终点在`target`的位置。

你可以做一些数量的移动 `numMoves` :

- 每次你可以选择向左或向右移动。
- 第 `i` 次移动（从  `i == 1` 开始，到 `i == numMoves` ），在选择的方向上走 `i` 步。

给定整数 `target` ，返回 *到达目标所需的 **最小** 移动次数(即最小 `numMoves` )* 。



##### 数学

首先target是正是负无所谓，无非就是换方向的问题，因此不妨假设方向是正的。那么答案有一个最小的下界n，也就是1到n的和必须不小于target，原因是，假如全都取正，总和都达不到target，那么一定不能通过改变某些步骤的方向来达到目的。。好，一直向前走，如果恰好第n步走的超过了target（也可以是正好到达target），假设超过的距离d是偶数，我们知道这个d<n，只需要把第d/2步改方向即可，此时答案就是n；下面讨论d为奇数的时候：很明显可以再走两步达到目的：第一步向回走，第二步向前走，然后把第(d+1)/2步的方向改为负，此时答案可以是n+2，那么有没有n+1的走法呢？可能有，肯定不是再向回走一步，因为这样位置小于target了，那么试试向后走一步，此时超过target距离为d+n+1<2n+1，如果这个数是偶数，那么我们可以把第(d+n+1)/2步改为向回走，此时答案是n+1



```c++
class Solution{
public:
	int reachNumber(int targe){
		target=abs(target);
		int k=0;
		while(target>0){
			k++;
			target-=k;
		}
		return target%2==0?k:k+1+k%2;
	}
};
```

