### lc-808

有 **A 和 B 两种类型** 的汤。一开始每种类型的汤有 `n` 毫升。有四种分配操作：

1. 提供 `100ml` 的 **汤A** 和 `0ml` 的 **汤B** 。
2. 提供 `75ml` 的 **汤A** 和 `25ml` 的 **汤B** 。
3. 提供 `50ml` 的 **汤A** 和 `50ml` 的 **汤B** 。
4. 提供 `25ml` 的 **汤A** 和 `75ml` 的 **汤B** 。

当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 `0.25` 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。

**注意** 不存在先分配 `100` ml **汤B** 的操作。

需要返回的值： **汤A** 先分配完的概率 + **汤A和汤B** 同时分配完的概率 / 2。返回值在正确答案 `10-5` 的范围内将被认为是正确的。



##### 记忆化搜索

```c++
class Solution {
public:
    double soupServings(int n) {
        n = ceil((double) n / 25);
        if (n >= 179) {
            return 1.0;
        }
        memo = vector<vector<double>>(n + 1, vector<double>(n + 1));
        return dfs(n, n);
    }

    double dfs(int a, int b) {
        if (a <= 0 && b <= 0) {
            return 0.5;
        } else if (a <= 0) {
            return 1;
        } else if (b <= 0) {
            return 0;
        }
        if (memo[a][b] > 0) {
            return memo[a][b];
        }
        memo[a][b] = 0.25 * (dfs(a - 4, b) + dfs(a - 3, b - 1) + 
                             dfs(a - 2, b - 2) + dfs(a - 1, b - 3));
        return memo[a][b];
    }
private:
    vector<vector<double>> memo;
};

```

