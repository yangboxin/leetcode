### lc-672

房间中有 n 只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。

这 4 个开关各自都具有不同的功能，其中：

开关 1 ：反转当前所有灯的状态（即开变为关，关变为开）
开关 2 ：反转编号为偶数的灯的状态（即 2, 4, ...）
开关 3 ：反转编号为奇数的灯的状态（即 1, 3, ...）
开关 4 ：反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, ...（即 1, 4, 7, 10, ...）
你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。

给你两个整数 n 和 presses ，执行完所有按压之后，返回 不同可能状态 的数量。



首先观察到按钮1最小（atomic）影响数是1；按钮2和3是2，考虑到这两个按钮是互相对称的情况，实际最小影响数也是1；按钮4是3，求得整个系统的最小影响灯泡数量是3，可以有如下转换形式：

```basic
1. 000 -> 111
2. 000 -> 010
3. 000 -> 101
4. 000 -> 100
```

不难得出，3个灯泡的最大变换情况是2 ^ 3 = 8种，那么我们就要探讨一下最大是否能够将这8种遍历结束，以及最小历经多少次press才能得到最多的变换情况数。

观察到：我们执行1可以仅变换第一颗灯泡、执行2可以仅变换第二颗灯泡、执行3、4可以仅变换第三颗灯泡，因此最大变换总数也就是8，这意味着当灯泡数大于2、press足够大时，答案是8，那么最小将这8种情况遍历完毕的次数呢？不难得出这个值是3，因此当灯泡数大于2，press数大于2时，返回值必为8。

接下来的事情就是考虑特殊情况，对于每种情况列出真值表即可。





```c++
class Solution {
public:
    int flipLights(int n, int presses) {
        if (presses > 2 && n > 2) return 8;
        if (n < 3) return 1 + (presses > 0) * n + (presses > 1 && n > 1);
        else return 1 + 3 * presses;
    }
};
```

