### lc-768

最多能完成排序的块II

arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

示例 1:

输入: arr = [5,4,3,2,1]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 

示例 2:

输入: arr = [2,1,3,4,4]
输出: 4
解释:
我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。
然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 



思路1：

若分块并排序后可以连接得到按升序排序的原数组，则在每个块内存在的数出现的频率应该与原数组相应位置数字的出现频率相同，故可以通过哈希表来记录排序后的原数组字母出现的频次，并在每次遍历时与假定的块比较。

```c++
int maxChunksToSorted(vector<int>& arr){
    unordered_map<int,int> map;
    vector<int>& sorted=arr;
    int res=0;
    sort(sorted.begin(),sorted.end());
    for(int i=0;i<sorted.size();i++){
        int a=arr[i],b=sorted[i];
				map[a]++;
        if(map[a]==0)
            map.erase(a);
       	map[b]--;
        if(map[b]==0)
            map.erase(b);
        if(map.size()==0)
            res++;
    }
    return res;
}
```



思路2：单调栈

对于可以分得的块：右边的块中元素一定严格大于左边块中的所有元素。

这样考虑：当前已经得到分好块的结果，若要加入一个数，这个数该如何分块？

若要加入的数>=最右边块中的所有元素，则可以将它作为一个新的块加入；

若要加入的数<最右边块中的一些元素，同时大于最右边块中的一些元素，则将其加入最右边的块中；

若要加入的数<最右边块中的所有元素，则应将其与最右边块中的元素左边的块相比较，直到没有已分好的块或在某个块中满足条件ii。

可以使用单调栈保存每个块的最大值。

```c++
int maxChunksToSorted(vector<int>& arr){
    stack<int> stk;
    int n=arr.size();
    for(int& num:arr){
        if(stk.empty() || stk.top()<=num){
            stk.emplace(num);
        }
        else{
            int top=stk.top();
            stk.pop();
            while(!stk.empty()&&stk.top()>num){
                stk.pop();//模拟上述步骤ii
            }
            stk.push(top);//当找到满足上述步骤ii的块时，将当前块与之前弹出的块合并。
        }
    }
    return stk.size();
}
```

### lc-41

缺失的第一个正数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

示例 1：

输入：nums = [1,2,0]
输出：3
示例 2：

输入：nums = [3,4,-1,1]
输出：2
示例 3：

输入：nums = [7,8,9,11,12]
输出：1

- `1 <= nums.length <= 5 * 105`
- `-2^31 <= nums[i] <= 2^31 - 1`

根据鸽笼原理（抽屉原理）可以推断：在大小为n的数组中，最小没有出现的正整数范围为[1,n+1]。

当且仅当[1,n]都出现在数组中时答案为n+1。

故可以在[1,n+1]范围内使用哈希表记录每个数出现的频次，但题目限制我们使用常数级的额外空间，可以考虑对原数组做**标记**的方法来当成哈希表使用。

首先考虑[1,n+1]范围外的数：可以将其全部标记为n+1(实际可只标记<=0的数)；

对于[1,n]范围内的数，我们用原数组的[0,n-1]位置来对应其是否在原数组中出现，若num在原数组中出现，我们将原数组的[num-1]位置置为-abs(nums[num-1])表示其出现并且不会影响nums[num-1]在后续循环中的判断；

最后我们可以遍历原数组中[0,n-1]区域内第一个大于0的数的下标+1作为答案，若不存在，证明[1,n]全都出现在原数组中，答案为n+1。

```c++
int firstMissingPositive(vector<int>& nums){
    int n=nums.size();
    for(int i=0;i<n;i++){
		if(nums[i]<=0)
            nums[i]=n+1;
    }
    for(int i=0;i<n;i++){
		int num=abs(nums[i]);
        if(num<=n){
            nums[num-1]=-abs(nums[num-1]);
        }
    }
    for(int i=0;i<n;i++){
        if(nums[i]>0)
            return i+1;
    }
    return n+1;
}
```

