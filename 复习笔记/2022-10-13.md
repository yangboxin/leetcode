### lc-769

给定一个长度为 `n` 的整数数组 `arr` ，它表示在 `[0, n - 1]` 范围内的整数的排列。

我们将 `arr` 分割成若干 **块** (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。

返回数组能分成的最多块数量。



考虑这样一件事情，我们新建一个数组num，其内放置着arr升序排序后的数字，将这个数组与arr比对，我们可以发现：在一个「块」内，不可能出现一个数字的值比这个「块」最大的下标还大，因为这样不可能使得这个「块」内放置着所有的应放置的整数同时还包含这个更大的数。所以遍历arr和num，记录arr[i]当前的最大值m，当m等于num[i]时，分块数+1



```c++
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int n=arr.size();
        int res=0,m=0;
        for(int i=0;i<n;i++){
            m=max(m,arr[i]);
            if(m==i)
                res++;
        }
        return res;
    }
};
```

