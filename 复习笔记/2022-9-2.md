### lc-687

给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。

两个节点之间的路径长度 由它们之间的边数表示。



dfs后序遍历，保证每个节点的子节点都已经处理完毕。

```c++
int res=0;
int dfs(TreeNode* root,TreeNode* p){
	if(!root)
		return 0;
	int left=dfs(root->left,root);
	int right=dfs(root->right,root);
	res=max(left+right,res);
	if(p&&root->val==p->val){
		return max(left,right)+1; 
	}
	else
		return 0;
}
int longestUnivaluPath(TreeNode* root){
	dfs(root,nullptr);
	return res;
}
```





### lc-200

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

示例 1：

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1



```c++
class Solution {
public:
    void dfs(vector<vector<char>>& grid,int i,int j){
        int m=grid.size(),n=grid[0].size();
        if(i<0||i>=m||j<0||j>=n||grid[i][j]=='0')
            return;
        grid[i][j]='0';
        dfs(grid,i+1,j);
        dfs(grid,i,j+1);
        dfs(grid,i-1,j);
        dfs(grid,i,j-1);
    }
    int numIslands(vector<vector<char>>& grid) {
        int m=grid.size(),n=grid[0].size();
        int res=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    res++;
                    dfs(grid,i,j);
                }
            }
        }
        return res;
    }
};
```





### lc-143

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        ListNode* fast=head,*slow=head;
        while(fast->next!=nullptr&&fast->next->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
        }
        //reverse slow
        ListNode* cur=slow->next;
        slow->next=nullptr;
        ListNode* prev=nullptr;
        while(cur){
            ListNode* tmp=cur->next;
            cur->next=prev;            
            prev=cur;
            cur=tmp;
        }
        //merge
        ListNode* tmp=head;
        while(prev){
            ListNode* prevnext=prev->next;
            ListNode* tmpnext=tmp->next;
            tmp->next=prev;
            tmp=tmpnext;
            prev->next=tmp;
            prev=prevnext;
        }
    }
};
```





### lc-139

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。



```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n=wordDict.size();
        unordered_set<int> uset;
        auto dfs=[&](auto&& me,string&& s1)->bool{
            if(s1.size()<s.size()){
                bool res=0;
                for(int i=0;i<n;i++){
                    if(uset.count(s1.size()+wordDict[i].size())||
                    wordDict[i]!=s.substr(s1.size(),wordDict[i].size()))
                    continue;
                    uset.insert(s1.size()+wordDict[i].size());
                    res=me(me,s1+wordDict[i]);
                    if(res)
                        return 1;    
                }
                return res;
            }
            else    
                return 1;
        };
        return dfs(dfs,"");
    }
};
```

