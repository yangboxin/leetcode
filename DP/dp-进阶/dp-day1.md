### 鸡蛋掉落

给你 **2 枚相同** 的鸡蛋，和一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑。

已知存在楼层 `f` ，满足 `0 <= f <= n` ，任何从 **高于** `f` 的楼层落下的鸡蛋都 **会碎** ，从 **`f` 楼层或比它低** 的楼层落下的鸡蛋都 **不会碎** 。

每次操作，你可以取一枚 **没有碎** 的鸡蛋并把它从任一楼层 `x` 扔下（满足 `1 <= x <= n`）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。

请你计算并返回要确定 `f` **确切的值** 的 **最小操作次数** 是多少？



##### 动态规划

若只有一个鸡蛋，则必须从第一层开始逐层测试。

而有两个鸡蛋时，则存在两种情况：

1. 取任意j，在[1,j]中任意取一k，把其中一个鸡蛋从第k层扔下，若鸡蛋碎了，则需要在剩下的楼层里从第一层开始逐层测试。
2. 若鸡蛋没碎，则转化为验证剩余楼层（j-k层）。

定义动态规划数组dp[i] [j]，表示使用i枚鸡蛋验证j层楼。

0层楼不需要验证，dp[0] [0]=dp[1] [0]=0。



**若只有一个鸡蛋，则必须从第一层开始逐层测试。**

所以dp[0] [i]=i, (1<=i<=n)

而对于任意的j层楼，对于其中的任意第k层楼：
$$
dp[1][j]=min(dp[1][j],max(dp[0][k-1]+1,dp[1][j-k]+1))
$$


```c++
class Solution {
public:
    int twoEggDrop(int n) {
        vector<vector<int>> dp(2,vector(n+1,INT_MAX));
        dp[0][0]=dp[1][0]=0;
        for(int i=1;i<=n;i++){  
            dp[0][i]=i;
        }   
        for(int j=1;j<=n;j++){
            for(int k=1;k<=j;k++){
                dp[1][j]=min(dp[1][j],max(dp[0][k-1]+1,dp[1][j-k]+1));
            }
        }
        return dp[1][n];
    }
};
```

